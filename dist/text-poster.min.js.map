{"version":3,"sources":["text-poster.js"],"names":["f","exports","module","define","amd","window","global","self","this","TextPoster","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","render","container","text","options","arguments","undefined","_Object$assign","Object","assign","maxLineHeight","minLineHeight","lineSpacing","firstChild","removeChild","lineContainer","document","createElement","classList","add","append","lastHeight","split","filter","each","forEach","line","words","fromWord","toWord","lineElement","sizeFactor","textContent","slice","join","clientWidth","clientHeight","style","left","concat","transform","top"],"mappings":"CAAA,SAAUA,GAAG,GAAoB,iBAAVC,SAAoC,oBAATC,OAAsBA,OAAOD,QAAQD,SAAS,GAAmB,mBAATG,QAAqBA,OAAOC,IAAKD,OAAO,GAAGH,OAAO,EAA0B,oBAATK,OAAwBA,OAA+B,oBAATC,OAAwBA,OAA6B,oBAAPC,KAAsBA,KAAYC,MAAOC,WAAaT,KAA/T,CAAsU,WAAqC,OAAmB,SAASU,EAAEC,EAAEC,EAAEC,GAAG,SAASC,EAAEC,EAAEf,GAAG,IAAIY,EAAEG,GAAG,CAAC,IAAIJ,EAAEI,GAAG,CAAC,IAAIC,EAAE,mBAAmBC,SAASA,QAAQ,IAAIjB,GAAGgB,EAAE,OAAOA,EAAED,GAAE,GAAI,GAAGG,EAAE,OAAOA,EAAEH,GAAE,GAAI,IAAII,EAAE,IAAIC,MAAM,uBAAuBL,EAAE,KAAK,MAAMI,EAAEE,KAAK,mBAAmBF,EAAE,IAAIG,EAAEV,EAAEG,GAAG,CAACd,QAAQ,IAAIU,EAAEI,GAAG,GAAGQ,KAAKD,EAAErB,QAAQ,SAASS,GAAoB,OAAOI,EAAlBH,EAAEI,GAAG,GAAGL,IAAeA,IAAIY,EAAEA,EAAErB,QAAQS,EAAEC,EAAEC,EAAEC,GAAG,OAAOD,EAAEG,GAAGd,QAAQ,IAAI,IAAIiB,EAAE,mBAAmBD,SAASA,QAAQF,EAAE,EAAEA,EAAEF,EAAEW,OAAOT,IAAID,EAAED,EAAEE,IAAI,OAAOD,EAA7b,CAA4c,CAACW,EAAE,CAAC,SAASR,EAAQf,EAAOD,GAC11B,aAgFAC,EAAOD,QAAU,CACfyB,OAhEF,SAAgBC,EAAWC,GAczB,IAbA,IAAIC,EAA6B,EAAnBC,UAAUN,aAA+BO,IAAjBD,UAAU,GAAmBA,UAAU,GAAK,GAO9EE,EAAiBC,OAAOC,OAAO,GANd,CACnBC,cAAe,GACfC,cAAe,KACfC,YAAa,GAGwCR,GACnDM,EAAgBH,EAAeG,cAC/BC,EAAgBJ,EAAeI,cAC/BC,EAAcL,EAAeK,YAG1BV,EAAUW,YACfX,EAAUY,YAAYZ,EAAUW,YAGlC,IAAIE,EAAgBC,SAASC,cAAc,OAC3CF,EAAcG,UAAUC,IAAI,kBAC5BjB,EAAUkB,OAAOL,GACjB,IAAIM,EAAa,EACLlB,EAAKmB,MAAM,MAAMC,OAAO,SAAUC,GAC5C,OAAqB,EAAdA,EAAKzB,SAER0B,QAAQ,SAAUC,GAKtB,IAJA,IAAIC,EAAQD,EAAKJ,MAAM,KACnBM,EAAW,EACXC,EAAS,EAEND,EAAWD,EAAM5B,QAAQ,CAC9B,IAAI+B,EAAcd,SAASC,cAAc,OACzCa,EAAYZ,UAAUC,IAAI,QAC1BJ,EAAcK,OAAOU,GAGrB,IAFA,IAAIC,EAAa,EAGfF,GAAU,EACVC,EAAYE,YAAcL,EAAMM,MAAML,EAAUC,GAAQK,KAAK,KAC7DH,EAAa7B,EAAUiC,YAAcL,EAAYK,YAC1CN,EAASF,EAAM5B,QAAU+B,EAAYM,aAAeL,EAAa7B,EAAUkC,aAAezB,IAE/FkB,EAASF,EAAM5B,SACjB8B,GAAU,GAGZC,EAAYE,YAAcL,EAAMM,MAAML,EAAUC,GAAQK,KAAK,KAC7DH,EAAa7B,EAAUiC,YAAcL,EAAYK,YAE7CL,EAAYM,aAAeL,EAAa7B,EAAUkC,aAAe1B,IACnEqB,EAAarB,EAAgBR,EAAUkC,aAAeN,EAAYM,aAClEN,EAAYO,MAAMC,KAAO,GAAGC,QAAQrC,EAAUiC,YAAcL,EAAYK,YAAcJ,GAAc,EAAG,OAGzGD,EAAYO,MAAMG,UAAY,SAASD,OAAOR,EAAY,KAC1DD,EAAYO,MAAMI,IAAM,GAAGF,OAAOlB,EAAY,MAC9CA,GAAcS,EAAYM,aAAeL,EAAanB,EACtDgB,EAAWC,KAGfd,EAAcsB,MAAMI,IAAM,GAAGF,QAAQrC,EAAUkC,aAAef,GAAc,EAAG,SAO/E,KAAK,GAAG,CAAC,GArFuW,CAqFnW","file":"text-poster.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.TextPoster = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\n/**\n * Places poster-style text inside a container\n *\n * The container will be emptied of whatever children it has (which allows successive invocations).\n *\n * @param {HTMLElement} container\n *  A block element in which to place the text.\n * @param {String} text\n *  The text to typeset\n * @param {Object} options\n *  Options:\n *    - maxLineHeight (default: 0.2) Maximum line height (as a percentage of the block's width)\n *    - minLineHeight (default: 0.044) Minimum line height (as a percentage of the block's width)\n *    - lineSpacing (default: 0) Space, in pixels, to place between lines.\n */\nfunction render(container, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var defaultOptions = {\n    maxLineHeight: 0.2,\n    minLineHeight: 0.044,\n    lineSpacing: 0\n  };\n\n  var _Object$assign = Object.assign({}, defaultOptions, options),\n      maxLineHeight = _Object$assign.maxLineHeight,\n      minLineHeight = _Object$assign.minLineHeight,\n      lineSpacing = _Object$assign.lineSpacing; // Clear the container\n\n\n  while (container.firstChild) {\n    container.removeChild(container.firstChild);\n  }\n\n  var lineContainer = document.createElement('div');\n  lineContainer.classList.add('line-container');\n  container.append(lineContainer);\n  var lastHeight = 0;\n  var lines = text.split('\\n').filter(function (each) {\n    return each.length > 0;\n  });\n  lines.forEach(function (line) {\n    var words = line.split(' ');\n    var fromWord = 0;\n    var toWord = 0;\n\n    while (fromWord < words.length) {\n      var lineElement = document.createElement('div');\n      lineElement.classList.add('line');\n      lineContainer.append(lineElement);\n      var sizeFactor = 1;\n\n      do {\n        toWord += 1;\n        lineElement.textContent = words.slice(fromWord, toWord).join(' ');\n        sizeFactor = container.clientWidth / lineElement.clientWidth;\n      } while (toWord < words.length && lineElement.clientHeight * sizeFactor / container.clientHeight > minLineHeight);\n\n      if (toWord < words.length) {\n        toWord -= 1;\n      }\n\n      lineElement.textContent = words.slice(fromWord, toWord).join(' ');\n      sizeFactor = container.clientWidth / lineElement.clientWidth;\n\n      if (lineElement.clientHeight * sizeFactor / container.clientHeight > maxLineHeight) {\n        sizeFactor = maxLineHeight * container.clientHeight / lineElement.clientHeight;\n        lineElement.style.left = \"\".concat((container.clientWidth - lineElement.clientWidth * sizeFactor) / 2, \"px\");\n      }\n\n      lineElement.style.transform = \"scale(\".concat(sizeFactor, \")\");\n      lineElement.style.top = \"\".concat(lastHeight, \"px\");\n      lastHeight += lineElement.clientHeight * sizeFactor + lineSpacing;\n      fromWord = toWord;\n    }\n  });\n  lineContainer.style.top = \"\".concat((container.clientHeight - lastHeight) / 2, \"px\");\n}\n\nmodule.exports = {\n  render: render\n};\n\n},{}]},{},[1])(1)\n});\n"]}