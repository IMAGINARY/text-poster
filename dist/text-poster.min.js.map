{"version":3,"sources":["text-poster.js"],"names":["f","exports","module","define","amd","window","global","self","this","TextPoster","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","render","container","text","options","arguments","undefined","_Object$assign","Object","assign","maxLineHeight","minLineHeight","lineSpacing","firstChild","removeChild","lineContainer","document","createElement","classList","add","append","lastHeight","split","map","line","trim","filter","each","forEach","lineText","smallText","substr","words","fromWord","toWord","lineElement","sizeFactor","textContent","slice","join","clientWidth","clientHeight","Math","min","style","left","concat","transform","top"],"mappings":"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","file":"text-poster.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.TextPoster = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\n/**\n * Places poster-style text inside a container\n *\n * The container will be emptied of whatever children it has (which allows successive invocations).\n *\n * @param {HTMLElement} container\n *  A block element in which to place the text.\n * @param {String} text\n *  The text to typeset\n * @param {Object} options\n *  Options:\n *    - maxLineHeight (default: 0.2) Maximum line height (as a percentage of the block's width)\n *    - minLineHeight (default: 0.044) Minimum line height (as a percentage of the block's width)\n *    - lineSpacing (default: 0) Space, in pixels, to place between lines.\n */\nfunction render(container, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var defaultOptions = {\n    maxLineHeight: 0.2,\n    minLineHeight: 0.044,\n    lineSpacing: 0\n  };\n\n  var _Object$assign = Object.assign({}, defaultOptions, options),\n      maxLineHeight = _Object$assign.maxLineHeight,\n      minLineHeight = _Object$assign.minLineHeight,\n      lineSpacing = _Object$assign.lineSpacing; // Clear the container\n\n\n  while (container.firstChild) {\n    container.removeChild(container.firstChild);\n  }\n\n  var lineContainer = document.createElement('div');\n  lineContainer.classList.add('line-container');\n  container.append(lineContainer);\n  var lastHeight = 0;\n  var lines = text.split('\\n').map(function (line) {\n    return line.trim();\n  }).filter(function (each) {\n    return each.length > 0;\n  });\n  lines.forEach(function (line) {\n    var lineText = line;\n    var smallText = false; // Check for escape characters\n\n    if (line.substr(0, 2) === '@@') {\n      lineText = line.substr(2).trim();\n      smallText = true;\n    }\n\n    if (lineText.length > 0) {\n      var words = lineText.split(' ');\n      var fromWord = 0;\n      var toWord = 0;\n\n      while (fromWord < words.length) {\n        var lineElement = document.createElement('div');\n        lineElement.classList.add('line');\n        lineContainer.append(lineElement);\n        var sizeFactor = 1; // Add words until the line's height becomes smaller than the minimum\n\n        do {\n          toWord += 1;\n          lineElement.textContent = words.slice(fromWord, toWord).join(' ');\n          sizeFactor = container.clientWidth / lineElement.clientWidth;\n        } while (toWord <= words.length && lineElement.clientHeight * sizeFactor / container.clientHeight >= minLineHeight); // If we exited the loop because the height became less than the minimum\n\n\n        if (toWord <= words.length) {\n          // If possible remove one word to go back above the minimum\n          if (toWord > fromWord + 1) {\n            toWord -= 1;\n          }\n        }\n\n        lineElement.textContent = words.slice(fromWord, toWord).join(' ');\n\n        if (smallText) {\n          // Make the line the minimum height unless it doesn't fit and it needs shrinking\n          // (this happens with single words that are very long)\n          sizeFactor = Math.min(container.clientWidth / lineElement.clientWidth, minLineHeight * container.clientHeight / lineElement.clientHeight);\n        } else {\n          // Make the line the full width unless it goes over the max height and it needs\n          // shrinking\n          sizeFactor = Math.min(container.clientWidth / lineElement.clientWidth, maxLineHeight * container.clientHeight / lineElement.clientHeight);\n        } // Center the line\n\n\n        lineElement.style.left = \"\".concat((container.clientWidth - lineElement.clientWidth * sizeFactor) / 2, \"px\");\n        lineElement.style.transform = \"scale(\".concat(sizeFactor, \")\");\n        lineElement.style.top = \"\".concat(lastHeight, \"px\");\n        lastHeight += lineElement.clientHeight * sizeFactor + lineSpacing;\n        fromWord = toWord;\n      }\n    }\n  });\n  lineContainer.style.top = \"\".concat((container.clientHeight - lastHeight) / 2, \"px\");\n}\n\nmodule.exports = {\n  render: render\n};\n\n},{}]},{},[1])(1)\n});\n"]}